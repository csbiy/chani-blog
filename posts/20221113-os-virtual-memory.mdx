---
id: 125
title: "메모리 가상화"
description: ""
date: "2022-11-13 21:46:23"
tags: ['Computer Science', 'OS']
---
## 메모리 가상화 

여러개의 프로세스가 존재하는 환경에서 각 프로세스는 자기가 할당받은 메모리에만 접근해야 한다. 그 외의 프로세스가 가진 메모리를 읽거나 변경하는 경우는 존재해서는 안된다. 

![](/images/os-virtual-memory-01.png)

- 메모리 가상화 :  하나의 물리 메모리를 공유하는 다수의 프로세스에게 각 프로세스는 마치 자신이 물리메모리 주소 0부터 시작하는 하나의 전체 물리 메모리를 사용하고 있는것처럼 해주는 운영체제의 기능 


## 주소 변환 

- 하드웨어 기반 주소 변환이라고도 부른다. 
- 프로그램의 모든 메모리 참조값을 실제 물리적인 메모리 위치로 변환해준다. 
- 이를 위해서는 CPU 당 1쌍씩 존재하는 2개의 하드웨어 레지스터가 필요하고, 이와 같이 CPU에서 주소변환의 역할을 하는 장치를 ```MMU (Memory Management Unit)```이라고 부른다. 

1. Base Register
2. Limit (Bound) Register 

```
물리메모리 주소값 = 논리 메모리주소값 + Base Register 값 
```

- Limit Register는 프로세스가 자신의 메모리 주소값만을 접근함을 보장시켜준다. 예를 들어서 Limit Register가 16KB 면 , Base + 논리 메모리주소값이 16KB가 넘게되면 예외가 떨어진다. 

## 동적 재배치 

- 동적 재배치 (dynamic reloadling) : Base , Limit Register를 이용하여 프로세스의 메모리 주소를 변환하는데, 프로세스 메모리 주소를 쪼개지 않고 통째로 배치한다. 즉 프로그램 전체 메모리 주소가 4GB라면 실제로 사용되는 공간이 100MB 이하여도 4GB가 로딩되야하는 방식으로 메모리 낭비가 매우 심하다. 이처럼 할당된 영역에서 사용되지 않아서 낭비되는 메모리를 ```Internal Fragmentation (내부 단편화)```라고 부른다.

![](/images/os-virtual-memory-02.png)

## Segmentation 

- MMU마다 하나의 Base, Limit Register값이 아닌 세그먼트라는 단위별로 Base,Limit Register 값이 존재한다. 즉 전체 프로세스를 메모리에 올리는게 아니라, ```프로세스를 세그먼트라는 단위로 쪼개서 올렸다 내렸다를 반복한다. ```

![](/images/os-virtual-memory-03.png)

( * 세그먼트 : 특정 길이를 가지는 연속적인 메모리 주소 공간 )

- Segment 별로 메모리 크기가 동일하게 할당되지 않아도 된다. 즉 아래와 같이 코드 세그먼트 ,힙 세그먼트 , 스택 세그먼트로 나누어 할당될 수도 있다. 
  
![](/images/os-virtual-memory-04.png)

- 동적 재배치 방식에 비해 얻는 장점 : 운영체제가 각 주소 공간을 세그먼트 단위로 가상 주소 공간을 물리 메모리에 재배치하기 때문에 전체 주소 공간이 하나의 Base ,Limit Register 값을 갖는 형태보다 메모리를 절약할 수 있다. 

- 단점 : 세그먼트의 크기가 제각각이기 떄문에, Segment가 메모리에서 빠지면 크기가 다른 잔여메모리 공간이 생긴다. (External Fragmentation , 외부단편화)
  
위 단점의 해결방법으로 기존의 세그먼트를 정리하여 , 물리 메모리를 압축하는 방법이 있다. 

![](/images/os-virtual-memory-05.png)

세그먼트 압축하는 과정은 메모리,CPU에 부하가 큰 작업이라는 단점이 존재한다. 


## Paging 

//TODO 
