---
id: 178
title: "Java Virtual Thread - 경량 스레드로 동시성 프로그래밍"
description: "Java 21에서 정식 도입된 Virtual Thread의 개념, 동작 원리, 사용법과 주의사항"
date: "2026-01-04 13:22:00"
tags: ["Java", "Concurrency", "VirtualThread", "JDK21"]
---

## Virtual Thread가 필요한 이유

전통적인 Java 동시성 모델에서는 하나의 요청을 하나의 스레드가 처리하는 thread-per-request 방식이 일반적이었다. 코드가 직관적이고 디버깅도 쉽다. 근데 이게 좀 문제가 있다.

Platform Thread(기존 Java 스레드)는 OS 스레드와 1:1로 매핑된다. OS 스레드는 생성 비용이 높고, 스레드당 약 1MB의 스택 메모리를 차지한다. 8GB 메모리 서버에서 스레드만으로 메모리를 다 쓰려면 8,000개가 한계다. 실제로는 다른 자원도 써야 하니까 수천 개 수준에서 병목이 생긴다.

```text
요청 수 증가 → 스레드 수 증가 필요 → OS 스레드 한계 → 처리량 병목
```

이 문제를 해결하기 위해 Reactive Programming이나 비동기 방식이 등장했지만, 코드 복잡도가 급격히 증가하고 기존 thread-per-request 스타일의 장점을 포기해야 했다.

Virtual Thread는 이 딜레마를 해결한다. thread-per-request의 단순함은 유지하면서 OS 스레드 제약을 없앴다. 수백만 개의 동시 작업도 가능하다.

## Virtual Thread란

JDK 21에서 JEP 444로 들어온 Virtual Thread는 경량 스레드다. OS 스레드에 직접 매핑되지 않고 JVM이 자체적으로 스케줄링한다.

핵심은 M:N 스케줄링이다. 쉽게 말해서 여러 Virtual Thread가 적은 수의 OS 스레드를 돌려쓴다. 택시 합승이랑 비슷하다고 보면 된다.

![Virtual Thread 아키텍처](/images/virtual-thread-arch-new.png)

## Platform Thread vs Virtual Thread

| 구분 | Platform Thread | Virtual Thread |
|------|-----------------|----------------|
| OS 스레드 관계 | 1:1 매핑 | M:N 스케줄링 |
| 생성 비용 | 높음 (~1ms, ~1MB 스택) | 매우 낮음 (수 KB, 동적 확장) |
| 최대 개수 | 수천 개 수준 | 수백만 개 가능 |
| 스택 메모리 위치 | OS 메모리 | JVM Heap (GC 대상) |
| 데몬 여부 | 설정 가능 | 항상 데몬 |
| 우선순위 | 설정 가능 (1~10) | 고정 (NORM_PRIORITY) |
| 풀링 | 권장됨 | 권장되지 않음 |

## 동작 원리: Mount와 Unmount

Virtual Thread의 핵심 메커니즘은 mount/unmount다.

Virtual Thread가 실행되려면 실제 OS 스레드가 필요하다. 이때 Virtual Thread를 태워서 실행하는 Platform Thread를 Carrier Thread라고 부른다.

![Virtual Thread Mount/Unmount](/images/virtual-thread-mount-new.png)

- **Mount**: Virtual Thread가 Carrier Thread에 올라타서 실행
- **Unmount**: Blocking I/O 발생 시 Carrier Thread에서 내려옴

Blocking I/O(파일 읽기, 네트워크 요청 등)가 발생하면 Virtual Thread는 Carrier Thread에서 unmount된다. 이때 Carrier Thread는 다른 Virtual Thread를 mount해서 실행할 수 있다. Blocking 작업이 완료되면 Virtual Thread는 다시 스케줄러에 의해 Carrier Thread에 mount되어 이어서 실행된다.

그래서 Blocking I/O가 발생해도 OS 스레드가 놀지 않는다. 이게 Virtual Thread의 핵심이다.

## Scheduler 구조

Virtual Thread의 스케줄러는 Work-stealing 알고리즘을 사용하는 ForkJoinPool이다.

```bash
# 스케줄러 병렬성 조정 (기본값: 가용 프로세서 수)
java -Djdk.virtualThreadScheduler.parallelism=16 MyApp
```

각 Carrier Thread는 자신의 작업 큐를 가지고 있고, 큐가 비면 다른 Carrier Thread의 큐에서 작업을 가져온다. 이를 통해 부하가 자동으로 분산된다.

## 사용법

Virtual Thread 생성 방법은 여러 가지가 있다.

### Thread.startVirtualThread()

가장 간단한 방법이다.

```java
Thread vThread = Thread.startVirtualThread(() -> {
    System.out.println("Virtual Thread 실행: " + Thread.currentThread());
});
vThread.join();
```

### Thread.ofVirtual() Builder

스레드 이름 설정 등 세부 제어가 필요할 때 사용한다.

```java
// 단일 스레드 생성 시 이름 직접 지정
Thread vThread = Thread.ofVirtual()
    .name("worker-1")
    .start(() -> {
        System.out.println("Named Virtual Thread: " + Thread.currentThread().getName());
    });

// 여러 스레드 생성 시 ThreadFactory 활용 - 자동 번호 부여
ThreadFactory factory = Thread.ofVirtual().name("worker-", 0).factory();
Thread t1 = factory.newThread(() -> {});  // worker-0
Thread t2 = factory.newThread(() -> {});  // worker-1
```

### ExecutorService

실무에서 가장 많이 사용하는 방식이다. try-with-resources와 함께 사용하면 모든 작업이 완료될 때까지 대기한다.

```java
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            try {
                Thread.sleep(Duration.ofSeconds(1));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return i;
        });
    });
}  // 모든 작업 완료 후 자동으로 shutdown
```

위 코드는 10,000개의 Virtual Thread를 생성해서 각각 1초씩 대기하는 작업을 수행한다. Platform Thread였다면 10,000개의 OS 스레드가 필요했겠지만, Virtual Thread는 소수의 Carrier Thread만으로 이를 처리한다.

## 주의사항

### Pinning 문제

Virtual Thread가 Carrier Thread에서 unmount되지 못하고 고정되는 현상을 Pinning이라고 한다. 두 가지 경우에 걸린다.

1. synchronized 블록 내에서 Blocking I/O 수행
2. Native 메서드 실행 중

```java
// Pinning 발생 예시 - 피해야 함
synchronized (lock) {
    // Blocking I/O - Carrier Thread가 블록됨
    inputStream.read();
}

// 해결책: ReentrantLock 사용
private final ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    inputStream.read();  // Unmount 가능
} finally {
    lock.unlock();
}
```

Pinning이 발생하면 Carrier Thread 자체가 블록되어 Virtual Thread의 장점이 사라진다. 진단을 위해 다음 JVM 옵션을 사용할 수 있다.

```bash
# Pinning 발생 시 스택 트레이스 출력
-Djdk.tracePinnedThreads=full

# 문제 프레임만 간략히 출력
-Djdk.tracePinnedThreads=short
```

참고로 JDK 24에서는 JEP 491을 통해 synchronized 블록에서의 Pinning 문제가 해결될 예정이다.

### ThreadLocal 사용 주의

Virtual Thread는 수백만 개 생성될 수 있으므로, ThreadLocal에 무거운 객체를 저장하면 메모리 문제가 발생한다.

```java
// 피해야 함 - Virtual Thread마다 Connection 생성
private static final ThreadLocal<Connection> connHolder =
    ThreadLocal.withInitial(() -> createConnection());

// 권장 - Connection Pool 사용
private static final DataSource dataSource = createDataSource();
```

### Pooling 금지

Platform Thread는 생성 비용이 높아서 ThreadPool을 사용하는 게 일반적이다. 하지만 Virtual Thread는 생성 비용이 매우 낮으므로 풀링할 필요가 없다. 오히려 풀링하면 Virtual Thread의 장점을 활용하지 못한다.

```java
// 잘못된 사용 - Virtual Thread를 풀링
ExecutorService pool = Executors.newFixedThreadPool(100, Thread.ofVirtual().factory());

// 올바른 사용 - 작업마다 새 Virtual Thread 생성
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
```

## Virtual Thread가 적합한 경우

Virtual Thread는 모든 상황에서 Platform Thread보다 좋은 것이 아니다.

적합한 경우:
- I/O 바운드 작업이 많은 서버 애플리케이션
- 동시 요청 수가 수천 개 이상
- 짧은 작업이 많이 발생하는 경우

부적합한 경우:
- CPU 바운드 작업 (연산 위주)
- 동시 작업 수가 적은 경우
- synchronized를 많이 사용하는 레거시 코드 (JDK 24 이전)

## Spring Boot에서의 활용

Spring Boot 3.2부터 Virtual Thread를 쉽게 활성화할 수 있다.

```properties
# application.properties
spring.threads.virtual.enabled=true
```

이 설정 하나로 Tomcat의 요청 처리가 Virtual Thread 기반으로 전환된다. 기존 코드 수정 없이 바로 적용 가능하다.

### Connection Pool 설정

Virtual Thread를 쓴다고 Connection Pool 설정을 크게 바꿀 필요는 없다. 다만 주의할 점이 있다.

```yaml
# HikariCP 설정 예시
spring:
  datasource:
    hikari:
      maximum-pool-size: 10  # Virtual Thread 수만큼 늘리면 안 됨
      connection-timeout: 30000
```

Virtual Thread가 수만 개 떠 있어도 DB Connection은 여전히 비싼 자원이다. Pool 크기를 Virtual Thread 수에 맞춰 늘리면 DB가 죽는다. 기존 설정 그대로 유지하면 된다.

### WebFlux vs Virtual Thread

둘 다 높은 처리량을 목표로 하지만 접근 방식이 다르다.

| 구분 | WebFlux | Virtual Thread |
|------|---------|----------------|
| 프로그래밍 모델 | Reactive (Mono/Flux) | 동기식 (기존 방식) |
| 학습 곡선 | 높음 | 낮음 |
| 디버깅 | 어려움 | 쉬움 |
| 기존 코드 호환 | 전면 재작성 | 거의 그대로 |

이미 WebFlux로 잘 돌아가는 서비스라면 굳이 바꿀 필요 없다. 새 프로젝트거나 동기식 코드를 유지하고 싶다면 Virtual Thread가 좋은 선택이다.

## 정리

Virtual Thread는 꽤 쓸만한 기능이다. Reactive 코드 없이도 thread-per-request 모델로 높은 처리량을 낼 수 있다.

핵심 개념을 정리하면 다음과 같다.

- Virtual Thread는 JVM이 관리하는 경량 스레드로, OS 스레드와 M:N 관계
- Blocking I/O 발생 시 Carrier Thread에서 unmount되어 스레드 낭비 방지
- 풀링하지 말고 작업당 하나씩 생성
- synchronized 블록 내 Blocking I/O는 Pinning 유발 (ReentrantLock 권장)
- I/O 바운드 작업에 적합, CPU 바운드 작업에는 이점 없음

## 참고문헌

- [JEP 444: Virtual Threads](https://openjdk.org/jeps/444) - OpenJDK 공식 스펙
- [Virtual Threads - Oracle Java 21 Documentation](https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html)
- [JEP 491: Synchronize Virtual Threads without Pinning](https://openjdk.org/jeps/491) - Pinning 문제 해결 제안
