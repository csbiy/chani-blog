---
id: 179
title: "Java LTS 버전 총정리 - Java 8부터 25까지"
description: "Java LTS(Long-Term Support) 버전인 8, 11, 17, 21, 25의 주요 기능과 변경사항을 한눈에 정리"
date: "2026-01-10 14:30:00"
tags: ["Java", "JDK", "LTS"]
---

## LTS(Long-Term Support)란?

Oracle이 2017년부터 6개월마다 새 버전을 찍어내기 시작했는데, 솔직히 다 따라가기 힘들다. 그래서 중요한 건 **LTS 버전**이다. 이것만 Oracle에서 최소 8년 지원해준다.

| LTS 버전 | 출시일 | Premier Support 종료 |
|----------|--------|---------------------|
| Java 8   | 2014년 3월 | 2030년 12월 |
| Java 11  | 2018년 9월 | 2032년 1월 |
| Java 17  | 2021년 9월 | 2026년 9월 (Extended: 2029년) |
| Java 21  | 2023년 9월 | 2031년 9월 |
| Java 25  | 2025년 9월 | 2033년 9월 |

프로덕션에서는 LTS 쓰자. 6개월마다 버전 올리다간 운영팀이 먼저 나간다.

---

## Java 8 (2014년 3월)

Java 역사상 가장 큰 변화. 함수형 프로그래밍이 들어왔다. 아직도 8 쓰는 곳이 많은 이유가 있다.

### Lambda Expression

익명 클래스 쓸 때마다 얼마나 귀찮았는지. 이제 화살표 하나면 끝이다.

```java
// Before Java 8
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

// Java 8
Runnable runnable = () -> System.out.println("Hello");
```

### Stream API

for문 지옥에서 해방시켜준 일등공신. 체이닝으로 데이터를 흘려보내는 맛이 있다.

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

List<String> filtered = names.stream()
    .filter(name -> name.startsWith("A"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

### Optional

NPE 공포에서 어느 정도 해방된다. null을 감싸서 명시적으로 처리하게 해준다. 물론 `get()` 남발하면 의미 없다.

```java
Optional<String> optional = Optional.ofNullable(getValue());
String result = optional.orElse("default");
```

### 새로운 Date/Time API

드디어 쓸만한 날짜 API가 생겼다. 기존 `Date`, `Calendar`는 mutable에 API도 괴상했는데, `java.time`은 Joda-Time 만든 사람이 설계해서 깔끔하다.

```java
LocalDate date = LocalDate.now();
LocalDateTime dateTime = LocalDateTime.of(2024, 1, 15, 10, 30);
Duration duration = Duration.between(start, end);
```

### Default Method in Interface

인터페이스에 구현체를 넣을 수 있게 됐다. 하위 호환성 유지하면서 인터페이스 확장할 때 유용하다. 다만 다이아몬드 문제 조심.

```java
public interface Vehicle {
    default void start() {
        System.out.println("Starting...");
    }
}
```

---

## Java 11 (2018년 9월)

8 이후 첫 LTS. 이때부터 Oracle JDK가 상용 유료화되면서 OpenJDK, Temurin, Corretto 같은 배포판을 쓰기 시작했다.

### HTTP Client API

`HttpURLConnection` 쓰면서 고통받던 시절이 끝났다. 드디어 현대적인 HTTP 클라이언트가 생겼다.

```java
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .GET()
    .build();

HttpResponse<String> response = client.send(request,
    HttpResponse.BodyHandlers.ofString());
```

### var in Lambda

람다 파라미터에도 `var`를 쓸 수 있게 됐다. 왜 필요하냐면, 어노테이션 붙일 때 타입 선언이 필요하기 때문.

```java
// 어노테이션 적용이 가능해짐
list.stream()
    .map((@NotNull var item) -> item.toUpperCase())
    .collect(Collectors.toList());
```

### String 메서드 추가

자잘하지만 유용한 메서드들이 추가됐다.

```java
String text = "  Hello  ";
text.isBlank();       // false (공백만 있으면 true)
text.strip();         // "Hello" (유니코드 공백도 제거)
text.lines();         // Stream<String>으로 분리
"Ha".repeat(3);       // "HaHaHa"
```

### 단일 파일 실행

스크립트처럼 바로 실행 가능해졌다. 간단한 테스트할 때 편하다.

```bash
java HelloWorld.java
```

### 제거된 기능

- Java EE 모듈 (JAX-WS, JAXB 등) — Maven으로 별도 추가해야 함
- CORBA — 이거 쓰던 사람 있나?
- Nashorn JavaScript 엔진 — Deprecated (15에서 완전 제거)

---

## Java 17 (2021년 9월)

3년 만의 LTS. Preview로 떠돌던 기능들이 대거 정식 채택됐다. 여기서부터 모던 Java 느낌이 난다.

### Sealed Classes

상속을 제한할 수 있다. "이 클래스를 상속할 수 있는 건 얘네뿐이야"라고 선언하는 거다.

```java
public sealed class Shape
    permits Circle, Rectangle, Triangle {
}

public final class Circle extends Shape {
    private final double radius;
}

public final class Rectangle extends Shape {
    private final double width, height;
}

public non-sealed class Triangle extends Shape {
    // non-sealed: 누구나 상속 가능
}
```

**Sealed + Pattern Matching 조합**

진짜 힘을 발휘하는 건 switch와 같이 쓸 때다. 컴파일러가 모든 케이스를 체크해주기 때문에 `default`가 필요 없다.

```java
// sealed class의 모든 하위 타입을 처리하면 default 불필요
double area(Shape shape) {
    return switch (shape) {
        case Circle c    -> Math.PI * c.radius() * c.radius();
        case Rectangle r -> r.width() * r.height();
        case Triangle t  -> calculateTriangleArea(t);
        // default 없어도 컴파일 OK - 컴파일러가 exhaustive 체크
    };
}
```

나중에 `Pentagon`을 추가하면? `switch`에서 처리 안 한 곳은 **컴파일 에러**가 난다. 런타임에 터지는 것보다 100배 낫다.

### Pattern Matching for instanceof

`instanceof` 체크하고 바로 아래서 캐스팅하던 거, 이제 한 줄로 끝난다. 이거 은근 자주 쓴다.

```java
// Before
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.length());
}

// Java 17
if (obj instanceof String s) {
    System.out.println(s.length());
}
```

### Records

DTO 만들 때 getter, equals, hashCode, toString 보일러플레이트 지옥이었는데, 이제 한 줄이면 된다. Lombok 없이도 산다.

```java
public record Point(int x, int y) {}

// 자동 생성: 생성자, getter, equals, hashCode, toString
Point p = new Point(1, 2);
System.out.println(p.x());  // 1
```

**Records의 한계**

만능은 아니다. 알아둘 제약사항:

- **상속 불가**: Record는 암묵적으로 `final`이다. 다른 클래스를 상속할 수 없음
- **필드 변경 불가**: 모든 필드가 `final`. setter 없음. 불변 객체 전용
- **Lombok 대체?**: `@Builder`, `@With` 같은 건 직접 구현해야 함

```java
// Builder 패턴이 필요하면 직접 만들어야 한다
public record User(String name, int age) {
    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String name;
        private int age;
        // ...
    }
}
```

JPA Entity로는 못 쓴다. Entity는 기본 생성자와 setter가 필요한데 Record는 둘 다 없다. DTO 용도로만 쓰자.

### Text Blocks

JSON이나 SQL 문자열 만들 때 `\n` 지옥에서 해방됐다. 삼중 따옴표로 그냥 쓰면 된다.

```java
String json = """
    {
        "name": "John",
        "age": 30
    }
    """;
```

### Switch Expression

switch가 값을 반환할 수 있게 됐다. 화살표 문법으로 break도 필요 없고, fall-through 실수도 없다.

```java
String result = switch (day) {
    case MONDAY, FRIDAY -> "Work";
    case SATURDAY, SUNDAY -> "Rest";
    default -> "Unknown";
};
```

### 제거된 기능

- Applet API — 브라우저에서 Java 돌리던 시절의 유물
- Security Manager — 25년간 버텼지만 결국 Deprecated
- RMI Activation
- 실험적 AOT/JIT 컴파일러

---

## Java 21 (2023년 9월)

**게임 체인저**. Virtual Thread 하나만으로도 올라갈 가치가 있다. 클라우드 환경에서 Java의 경쟁력을 확 끌어올렸다.

### Virtual Threads

드디어 나왔다. 100만 개 스레드를 띄워도 JVM이 버틴다. 이제 Reactive 안 써도 된다는 얘기. 기존 thread-per-request 스타일 그대로 쓰면서 성능을 낼 수 있다.

```java
// 100만 개의 가상 스레드 생성 가능
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 1_000_000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(Duration.ofSeconds(1));
            return i;
        });
    });
}
```

**주의: Pinning 문제**

Virtual Thread가 carrier thread(실제 OS 스레드)에 고정되는 현상이다. 이러면 Virtual Thread의 장점이 사라진다.

```java
// Pinning 발생하는 코드 - 피해야 함
synchronized (lock) {
    Thread.sleep(1000);  // 이 동안 carrier thread가 묶임
}

// 해결책: ReentrantLock 사용
private final ReentrantLock lock = new ReentrantLock();
lock.lock();
try {
    Thread.sleep(1000);  // carrier thread 해제됨
} finally {
    lock.unlock();
}
```

`synchronized` 블록 안에서 blocking I/O나 `Thread.sleep()` 하면 문제가 생긴다. `ReentrantLock`으로 바꾸거나, `-Djdk.tracePinnedThreads=short` 옵션으로 pinning 발생 지점을 찾아서 수정하자.

### Sequenced Collections

`List`에서 첫 번째/마지막 원소 가져올 때 `get(0)`, `get(size()-1)` 쓰던 거 기억나나? 이제 `getFirst()`, `getLast()`로 깔끔하게 된다.

```java
SequencedCollection<String> list = new ArrayList<>();
list.addFirst("first");
list.addLast("last");
String first = list.getFirst();
String last = list.getLast();
list.reversed();  // 역순 뷰
```

### Record Patterns

Record를 패턴 매칭으로 한 번에 분해할 수 있다. 구조분해 할당 느낌이라 코드가 훨씬 간결해진다.

```java
record Point(int x, int y) {}

void printSum(Object obj) {
    if (obj instanceof Point(int x, int y)) {
        System.out.println(x + y);
    }
}
```

### Pattern Matching for switch (정식)

17에서 Preview로 나왔던 게 드디어 정식. 타입별로 분기 처리가 깔끔해진다.

```java
String format(Object obj) {
    return switch (obj) {
        case Integer i -> "Integer: " + i;
        case Long l    -> "Long: " + l;
        case String s  -> "String: " + s;
        case null      -> "null";
        default        -> "Unknown";
    };
}
```

### Structured Concurrency (Preview)

병렬 작업을 하나의 단위로 묶어서 관리한다. 하나가 실패하면 나머지도 자동 취소. 에러 처리가 훨씬 수월해진다.

```java
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    Future<String> user = scope.fork(() -> fetchUser());
    Future<Order> order = scope.fork(() -> fetchOrder());

    scope.join();
    scope.throwIfFailed();

    return new Response(user.resultNow(), order.resultNow());
}
```

### Scoped Values (Preview)

`ThreadLocal`의 단점(메모리 누수, mutable)을 해결한 대안. 불변 값을 스코프 단위로 공유한다.

```java
private static final ScopedValue<User> CURRENT_USER = ScopedValue.newInstance();

ScopedValue.where(CURRENT_USER, user)
    .run(() -> processRequest());
```

---

## Java 25 (2025년 9월)

현재 최신 LTS. Oracle에서 AI 개발 지원을 강조하고 있는데, Vector API나 Structured Concurrency가 그쪽과 연관된다. 전반적으로 성능 최적화에 집중한 버전.

### Scoped Values (정식)

21에서 Preview였던 게 드디어 정식. `ThreadLocal` 대체제로 쓸 수 있다.

### Flexible Constructor Bodies

드디어! `super()` 호출 전에 검증 로직을 넣을 수 있다. 지금까지 왜 안 됐는지 모를 정도로 자연스러운 기능.

```java
public class Child extends Parent {
    public Child(String value) {
        // super() 전에 검증 로직 가능
        if (value == null) {
            throw new IllegalArgumentException("value cannot be null");
        }
        super(value.toUpperCase());
    }
}
```

### Compact Object Headers

객체 헤더가 96-128비트에서 64비트로 줄었다. 객체마다 32-64비트씩 아끼니까 힙을 많이 쓰는 애플리케이션에서 체감된다.

### Module Import Declarations

모듈 단위로 import가 가능해졌다. `java.base` 하나면 기본 패키지 전부 커버.

```java
import module java.base;

// java.util.*, java.io.*, java.time.* 등 모두 사용 가능
```

### Compact Source Files

Hello World 치려고 `public class`에 `public static void main` 쓰던 시절은 갔다. 초보자 진입 장벽을 낮추려는 시도.

```java
// HelloWorld.java - class 선언 없이 바로 실행 가능
void main() {
    System.out.println("Hello, World!");
}
```

### Key Derivation Function API

양자 컴퓨팅 대비용 암호화 API인데, 솔직히 당장 쓸 일은 없을 듯. 나중을 위해 알아두면 좋다.

```java
KDF kdf = KDF.getInstance("HKDF-SHA256");
SecretKey derivedKey = kdf.deriveKey("AES",
    new HKDFParameterSpec(ikm, salt, info, 256));
```

### Generational Shenandoah

Shenandoah GC에 세대별 수집이 붙었다. 짧은 생명주기 객체가 많은 워크로드에서 효과적.

### JFR CPU-time Profiling

Linux에서 CPU 프로파일링 정확도가 올라갔다. 성능 튜닝할 때 유용.

### 제거된 기능

- 32-bit x86 포트 — 이제 64-bit만
- 실험적 Graal JIT 컴파일러 — GraalVM 쓰면 된다

---

## LTS 버전 선택 가이드

| 상황 | 권장 버전 |
|------|----------|
| 레거시 시스템 유지보수 | Java 8 또는 11 |
| 신규 프로젝트 시작 | Java 21 또는 25 |
| Virtual Thread 필요 | Java 21+ |
| 최신 기능 + 장기 지원 | Java 25 |

### 버전 업그레이드 시 주의사항

1. **8 → 11**: Java EE 모듈 제거됨 (별도 의존성 추가 필요)
2. **11 → 17**: Reflection 접근 제한 강화 (`--add-opens` 필요할 수 있음)
3. **17 → 21**: 대부분 호환, Virtual Thread 도입 고려
4. **21 → 25**: 32-bit 지원 종료, Security Manager 완전 제거

---

## 마무리

정리하자면, Java 8은 레거시, 11은 최소 버전, 17부터 모던 Java, 21이 현실적 선택, 25는 얼리어답터용이다.

신규 프로젝트라면 **21 이상**을 권장한다. Virtual Thread, Record, Pattern Matching 같은 기능을 쓰면 코드가 확 줄어든다. 아직 8 쓰고 있다면... 음, 화이팅.

---

## 참고 자료

- [OpenJDK JDK 25](https://openjdk.org/projects/jdk/25/)
- [Oracle Java SE Support Roadmap](https://www.oracle.com/java/technologies/java-se-support-roadmap.html)
- [InfoWorld - JDK 25 Features](https://www.infoworld.com/article/3846172/jdk-25-the-new-features-in-java-25.html)
- [Java Version History - Wikipedia](https://en.wikipedia.org/wiki/Java_version_history)
